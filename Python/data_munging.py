# -*- coding: utf-8 -*-
"""Data Munging

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12UtSHMc-DyJILxvuP2P31cBQxQAEJNoI
"""

import pandas as pd

# index = ['QB' , 'RB' , 'WR']
# df = pd.DataFrame({
#     'A': [45, 28, 18],
#     'B': [50, 13, 15]
# }, index=index)

df = pd.read_csv('https://raw.githubusercontent.com/fantasydatapros/LearnPythonWithFantasyFootball/master/2022/06-Data%20Munging/01-Fantasy%20Pros%20Projections%20-%20(2022.08.25).csv')
type(df)

df.head()

', '.join(df.columns)

scoring_weights = {
    'receptions': 1, # PPR
    'receiving_yds': 0.1,
    'receiving_td': 6,
    'FL': -2, #fumbles lost
    'rushing_yds': 0.1,
    'rushing_td': 6,
    'passing_yds': 0.04,
    'passing_td': 4,
    'int': -2
}

df['FantasyPoints'] = (
    df['Receptions']*scoring_weights['receptions'] + df['ReceivingYds']*scoring_weights['receiving_yds'] + \
    df['ReceivingTD']*scoring_weights['receiving_td'] + df['FL']*scoring_weights['FL'] + \
    df['RushingYds']*scoring_weights['rushing_yds'] + df['RushingTD']*scoring_weights['rushing_td'] + \
    df['PassingYds']*scoring_weights['passing_yds'] + df['PassingTD']*scoring_weights['passing_td'] + \
    df['Int']*scoring_weights['int']
    )

# use loc to index certain rows that pertain to the data u wanna see
#rb_df = df.loc[df['Pos'] == 'RB' , ['Player' , 'Team' , 'Receptions', 'ReceivingYds']]
# rb_df.head()

# chain together and typically assorted by ascending value (worse to best)

df.sort_values(by='RushingYds', ascending=False).head()

# transpose makes it look cleaner?????
rb_df = df.loc[df['Pos'] == 'RB']
rb_df.describe().transpose()

rb_df['RushingAtt'].max()

rb_df['RushingAtt'].std()

rb_df['RushingAtt'].min()

rb_df['RushingAtt'].quantile(.60)

rb_df['RushingAtt'].quantile(.20)

rb_df['RushingTDRank'] = rb_df['RushingTD'].rank(ascending=False)

rb_df.sort_values(by='RushingTDRank')['Player']

rb_df['RushingAtt'].value_counts()

import seaborn as sns
sns.set_style('whitegrid')
sns.distplot(rb_df['RushingAtt'])

rb_df.values

rb_df = df.loc[df['Pos'] == 'RB']

rb_df.head()

base_columns = ['Player', 'Team', 'Pos']
rushing_columns = ['FantasyPoints', 'Receptions', 'ReceivingYds', 'ReceivingTD', 'RushingAtt', 'RushingYds', 'RushingTD', 'FL']
rb_df = df.loc[(df['Pos'] == 'RB', base_columns + rushing_columns)]

rb_df.head()

adp_df = pd.read_csv("https://raw.githubusercontent.com/fantasydatapros/LearnPythonWithFantasyFootball/master/2022/06-Data%20Munging/02-ADP%20(PPR)%20-%20(2022.08.23).csv", index_col=0 )

adp_df.head()

adp_df['ADP RANK'] = adp_df['AVG'].rank()

adp_df.head()

adp_df_cutoff = adp_df[:100]

adp_df_cutoff.shape

replacement_players = {
    'RB' : '',
    'WR' : '',
    'QB' : '',
    'TE' : '',
}
for _, row in adp_df_cutoff.iterrows():
  position = row['Pos']
  player = row['Player']
  if position in replacement_players:
    replacement_players[position] = player

replacement_players

df = df[['Player' , 'Pos' , 'Team', 'FantasyPoints']]
df.head()

# initialize an empty dictionary.
# this is where we are going to save our replacement players

replacement_players = {
    'RB': '',
    'QB': '',
    'WR': '',
    'TE': ''
}

"""

We can iterate over our DataFrame using the iterrows method.

It's similar to the items method for dictionary looping.

Instead of key, values in dict.items(), we get back the index, row in df.items()

Using iterrows, we can iterate over our DataFrame, and get access to each row's column values.

We can access these column value much like we would values in a dictionary, using the [] notation.


https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html

"""

for _, row in adp_df_cutoff.iterrows():

    position = row['Pos'] # extract out the position and player value from each row as we loop through it
    player = row['Player']

    if position in replacement_players: # if the position is in the dict's keys
        replacement_players[position] = player # set that player as the replacement player

replacement_players

replacement_values = {} # initialize an empty dictionary

for position, player_name in replacement_players.items():

    player = df.loc[df['Player'] == player_name]

    # because this is a series object we get back, we need to use the tolist method
    # to get back the series as a list. The list object is of length 1, and the 1 item has the value we need.
    # we tack on a [0] to get the value we need.

    replacement_values[position] = player['FantasyPoints'].tolist()[0]

print(replacement_values)

pd.set_option('chained_assignment', None)
df = df.loc[df['Pos'].isin(['QB', 'RB' , 'WR' , 'TE'])]
df['VOR'] = df.apply(
    lambda row: row['FantasyPoints'] - replacement_values.get(row['Pos']), axis = 1
)

# built in that shows all rows
pd.set_option('display.max_rows', None)
df.sort_values(by='VOR', ascending=False).head()

df['VOR Rank'] = df['VOR'].rank(ascending=False)
df.sort_values(by='VOR Rank').head()

df.groupby('Pos')['VOR'].describe()

df['VOR'] = df['VOR'].apply(lambda x: (x - df['VOR'].min()) / (df['VOR'].max() - df['VOR'].min()))

df = df.sort_values(by='VOR Rank')
df.head(100)

df.groupby('Pos')['VOR'].describe()

import seaborn as sns
num_teams = 12
num_spots = 16
draft_pool = num_teams * num_spots
df_copy = df[:num_teams*num_spots]


sns.boxplot(x=df_copy['Pos'], y=df_copy['VOR']);

df = df.rename({
    'VOR': 'Value',
    'VOR Rank': 'Value Rank'
}, axis=1)

df.head()

adp_df = adp_df.rename({
    'PLAYER': 'Player',
    'POS': 'Pos',
    'AVG': 'Average ADP',
    'ADP RANK': 'ADP Rank'
}, axis=1) # let's rename some columns first.

adp_df = adp_df.drop('Team', axis=1)

df['Player'] = df['Player'].replace({
    'Kenneth Walker III': 'Kenneth Walker',
    'Travis Etienne Jr.': 'Travis Etienne',
    'Brian Robinson Jr.': 'Brian Robinson',
    'Pierre Strong Jr.': 'Pierre Strong',
    'Michael Pittman Jr.': 'Michael Pittman',
    'A.J. Dillon': 'AJ Dillon',
    'D.J. Moore': 'DJ Moore'
})

final_df = df.merge(adp_df, how='left', on=['Player', 'Pos'])

final_df.head(100)

# let's calculate the difference between our value rank and adp rank
final_df['Diff in ADP and Value'] = final_df['ADP Rank'] - final_df['Value Rank']

#removing outliers in ADP
final_df = final_df.loc[final_df['ADP Rank'] <= 212]

final_df.head()

draft_pool = final_df.sort_values(by='ADP Rank')[:196]

rb_draft_pool = draft_pool.loc[draft_pool['Pos'] == 'RB']
qb_draft_pool = draft_pool.loc[draft_pool['Pos'] == 'QB']
wr_draft_pool = draft_pool.loc[draft_pool['Pos'] == 'WR']
te_draft_pool = draft_pool.loc[draft_pool['Pos'] == 'TE']

# top 10 RB sleepers for this year's draft
rb_draft_pool.sort_values(by='Diff in ADP and Value', ascending=False)[:10]

# top 10 RB overvalued for this year's draft
rb_draft_pool.sort_values(by='Diff in ADP and Value', ascending=True)[:10]

# top 10 WR sleepers for this year's draft
final_df.sort_values(by='Diff in ADP and Value', ascending=False)[:10]

# top 10 WR overvalued for this year's draft
wr_draft_pool.sort_values(by='Diff in ADP and Value', ascending=True)[:10]

# top 10 TE sleepers for this year's draft
te_draft_pool.sort_values(by='Diff in ADP and Value', ascending=False)[:10]

# top 10 TE overvalued for this year's draft
te_draft_pool.sort_values(by='Diff in ADP and Value', ascending=True)[:10]

# top 10 QB sleepers for this year's draft
qb_draft_pool.sort_values(by='Diff in ADP and Value', ascending=False)[:10]

# top 10 QB overvalued for this year's draft
qb_draft_pool.sort_values(by='Diff in ADP and Value', ascending=True)[:10]